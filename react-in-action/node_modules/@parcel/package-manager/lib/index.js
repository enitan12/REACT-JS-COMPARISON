var $5VgCY$fs = require("fs");
var $5VgCY$child_process = require("child_process");
var $5VgCY$path = require("path");
var $5VgCY$stream = require("stream");
var $5VgCY$events = require("events");
var $5VgCY$buffer = require("buffer");
var $5VgCY$util = require("util");
var $5VgCY$parcelcore = require("@parcel/core");
var $5VgCY$parceldiagnostic = require("@parcel/diagnostic");
var $5VgCY$parcelfs = require("@parcel/fs");
var $5VgCY$module = require("module");
var $5VgCY$semver = require("semver");
var $5VgCY$parcellogger = require("@parcel/logger");
var $5VgCY$parcelutils = require("@parcel/utils");
var $5VgCY$parcelnoderesolvercore = require("@parcel/node-resolver-core");
var $5VgCY$url = require("url");
var $5VgCY$assert = require("assert");
var $5VgCY$parcelworkers = require("@parcel/workers");
var $5VgCY$string_decoder = require("string_decoder");

var $parcel$global =
typeof globalThis !== 'undefined'
  ? globalThis
  : typeof self !== 'undefined'
  ? self
  : typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
  ? global
  : {};
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
function $parcel$exportWildcard(dest, source) {
  Object.keys(source).forEach(function(key) {
    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {
      return;
    }

    Object.defineProperty(dest, key, {
      enumerable: true,
      get: function get() {
        return source[key];
      }
    });
  });

  return dest;
}
var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequire0b48"];
if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequire0b48"] = parcelRequire;
}
parcelRequire.register("kbPbH", function(module, exports) {
module.exports = $eb2c8a8c861b77cd$var$isexe;
$eb2c8a8c861b77cd$var$isexe.sync = $eb2c8a8c861b77cd$var$sync;

function $eb2c8a8c861b77cd$var$checkPathExt(path, options) {
    var pathext = options.pathExt !== undefined ? options.pathExt : process.env.PATHEXT;
    if (!pathext) return true;
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) return true;
    for(var i = 0; i < pathext.length; i++){
        var p = pathext[i].toLowerCase();
        if (p && path.substr(-p.length).toLowerCase() === p) return true;
    }
    return false;
}
function $eb2c8a8c861b77cd$var$checkStat(stat, path, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) return false;
    return $eb2c8a8c861b77cd$var$checkPathExt(path, options);
}
function $eb2c8a8c861b77cd$var$isexe(path, options, cb) {
    $5VgCY$fs.stat(path, function(er, stat) {
        cb(er, er ? false : $eb2c8a8c861b77cd$var$checkStat(stat, path, options));
    });
}
function $eb2c8a8c861b77cd$var$sync(path, options) {
    return $eb2c8a8c861b77cd$var$checkStat($5VgCY$fs.statSync(path), path, options);
}

});

parcelRequire.register("hW7mX", function(module, exports) {
module.exports = $d0ed91d357a2b7ea$var$isexe;
$d0ed91d357a2b7ea$var$isexe.sync = $d0ed91d357a2b7ea$var$sync;

function $d0ed91d357a2b7ea$var$isexe(path, options, cb) {
    $5VgCY$fs.stat(path, function(er, stat) {
        cb(er, er ? false : $d0ed91d357a2b7ea$var$checkStat(stat, options));
    });
}
function $d0ed91d357a2b7ea$var$sync(path, options) {
    return $d0ed91d357a2b7ea$var$checkStat($5VgCY$fs.statSync(path), options);
}
function $d0ed91d357a2b7ea$var$checkStat(stat, options) {
    return stat.isFile() && $d0ed91d357a2b7ea$var$checkMode(stat, options);
}
function $d0ed91d357a2b7ea$var$checkMode(stat, options) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options.uid !== undefined ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== undefined ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
}

});

parcelRequire.register("hjhEx", function(module, exports) {
"use strict";
module.exports = (opts)=>{
    opts = opts || {};
    const env = opts.env || process.env;
    const platform = opts.platform || process.platform;
    if (platform !== "win32") return "PATH";
    return Object.keys(env).find((x)=>x.toUpperCase() === "PATH") || "Path";
};

});

parcelRequire.register("doLll", function(module, exports) {
"use strict";

var $9c123da95397c743$require$exec = $5VgCY$child_process.exec;

var $9c123da95397c743$require$execSync = $5VgCY$child_process.execSync;


var $9c123da95397c743$var$access = $5VgCY$fs.access;
var $9c123da95397c743$var$accessSync = $5VgCY$fs.accessSync;
var $9c123da95397c743$var$constants = $5VgCY$fs.constants || $5VgCY$fs;
var $9c123da95397c743$var$isUsingWindows = process.platform == "win32";
var $9c123da95397c743$var$fileNotExists = function(commandName, callback) {
    $9c123da95397c743$var$access(commandName, $9c123da95397c743$var$constants.F_OK, function(err) {
        callback(!err);
    });
};
var $9c123da95397c743$var$fileNotExistsSync = function(commandName) {
    try {
        $9c123da95397c743$var$accessSync(commandName, $9c123da95397c743$var$constants.F_OK);
        return false;
    } catch (e) {
        return true;
    }
};
var $9c123da95397c743$var$localExecutable = function(commandName, callback) {
    $9c123da95397c743$var$access(commandName, $9c123da95397c743$var$constants.F_OK | $9c123da95397c743$var$constants.X_OK, function(err) {
        callback(null, !err);
    });
};
var $9c123da95397c743$var$localExecutableSync = function(commandName) {
    try {
        $9c123da95397c743$var$accessSync(commandName, $9c123da95397c743$var$constants.F_OK | $9c123da95397c743$var$constants.X_OK);
        return true;
    } catch (e) {
        return false;
    }
};
var $9c123da95397c743$var$commandExistsUnix = function(commandName, cleanedCommandName, callback) {
    $9c123da95397c743$var$fileNotExists(commandName, function(isFile) {
        if (!isFile) {
            var child = $9c123da95397c743$require$exec("command -v " + cleanedCommandName + " 2>/dev/null" + " && { echo >&1 " + cleanedCommandName + "; exit 0; }", function(error, stdout, stderr) {
                callback(null, !!stdout);
            });
            return;
        }
        $9c123da95397c743$var$localExecutable(commandName, callback);
    });
};
var $9c123da95397c743$var$commandExistsWindows = function(commandName, cleanedCommandName, callback) {
    // Regex from Julio from: https://stackoverflow.com/questions/51494579/regex-windows-path-validator
    if (!/^(?!(?:.*\s|.*\.|\W+)$)(?:[a-zA-Z]:)?(?:(?:[^<>:"\|\?\*\n])+(?:\/\/|\/|\\\\|\\)?)+$/m.test(commandName)) {
        callback(null, false);
        return;
    }
    var child = $9c123da95397c743$require$exec("where " + cleanedCommandName, function(error) {
        if (error !== null) callback(null, false);
        else callback(null, true);
    });
};
var $9c123da95397c743$var$commandExistsUnixSync = function(commandName, cleanedCommandName) {
    if ($9c123da95397c743$var$fileNotExistsSync(commandName)) try {
        var stdout = $9c123da95397c743$require$execSync("command -v " + cleanedCommandName + " 2>/dev/null" + " && { echo >&1 " + cleanedCommandName + "; exit 0; }");
        return !!stdout;
    } catch (error) {
        return false;
    }
    return $9c123da95397c743$var$localExecutableSync(commandName);
};
var $9c123da95397c743$var$commandExistsWindowsSync = function(commandName, cleanedCommandName, callback) {
    // Regex from Julio from: https://stackoverflow.com/questions/51494579/regex-windows-path-validator
    if (!/^(?!(?:.*\s|.*\.|\W+)$)(?:[a-zA-Z]:)?(?:(?:[^<>:"\|\?\*\n])+(?:\/\/|\/|\\\\|\\)?)+$/m.test(commandName)) return false;
    try {
        var stdout = $9c123da95397c743$require$execSync("where " + cleanedCommandName, {
            stdio: []
        });
        return !!stdout;
    } catch (error) {
        return false;
    }
};
var $9c123da95397c743$var$cleanInput = function(s) {
    if (/[^A-Za-z0-9_\/:=-]/.test(s)) {
        s = "'" + s.replace(/'/g, "'\\''") + "'";
        s = s.replace(/^(?:'')+/g, "") // unduplicate single-quote at the beginning
        .replace(/\\'''/g, "\\'"); // remove non-escaped single-quote if there are enclosed between 2 escaped
    }
    return s;
};
if ($9c123da95397c743$var$isUsingWindows) $9c123da95397c743$var$cleanInput = function(s) {
    var isPathName = /[\\]/.test(s);
    if (isPathName) {
        var dirname = '"' + $5VgCY$path.dirname(s) + '"';
        var basename = '"' + $5VgCY$path.basename(s) + '"';
        return dirname + ":" + basename;
    }
    return '"' + s + '"';
};
module.exports = function commandExists(commandName, callback) {
    var cleanedCommandName = $9c123da95397c743$var$cleanInput(commandName);
    if (!callback && typeof Promise !== "undefined") return new Promise(function(resolve, reject) {
        commandExists(commandName, function(error, output) {
            if (output) resolve(commandName);
            else reject(error);
        });
    });
    if ($9c123da95397c743$var$isUsingWindows) $9c123da95397c743$var$commandExistsWindows(commandName, cleanedCommandName, callback);
    else $9c123da95397c743$var$commandExistsUnix(commandName, cleanedCommandName, callback);
};
module.exports.sync = function(commandName) {
    var cleanedCommandName = $9c123da95397c743$var$cleanInput(commandName);
    if ($9c123da95397c743$var$isUsingWindows) return $9c123da95397c743$var$commandExistsWindowsSync(commandName, cleanedCommandName);
    else return $9c123da95397c743$var$commandExistsUnixSync(commandName, cleanedCommandName);
};

});

parcelRequire.register("dMi1x", function(module, exports) {








if (process.env.READABLE_STREAM === "disable" && $5VgCY$stream) {
    module.exports = $5VgCY$stream.Readable;
    Object.assign(module.exports, $5VgCY$stream);
    module.exports.Stream = $5VgCY$stream;
} else {
    exports = module.exports = (parcelRequire("1AM0g"));
    exports.Stream = $5VgCY$stream || exports;
    exports.Readable = exports;
    exports.Writable = (parcelRequire("5rzHA"));
    exports.Duplex = (parcelRequire("lWLE4"));
    exports.Transform = (parcelRequire("25qY5"));
    exports.PassThrough = (parcelRequire("1EHdT"));
    exports.finished = (parcelRequire("hKh6s"));
    exports.pipeline = (parcelRequire("2CGpz"));
}

});
parcelRequire.register("1AM0g", function(module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
module.exports = $128e63aad4db5ad2$var$Readable;
/*<replacement>*/ var $128e63aad4db5ad2$var$Duplex;
/*</replacement>*/ $128e63aad4db5ad2$var$Readable.ReadableState = $128e63aad4db5ad2$var$ReadableState;

var $128e63aad4db5ad2$require$EE = $5VgCY$events.EventEmitter;
var $128e63aad4db5ad2$var$EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
};

var $dFjLx = parcelRequire("dFjLx");

var $128e63aad4db5ad2$require$Buffer = $5VgCY$buffer.Buffer;
var $128e63aad4db5ad2$var$OurUint8Array = $parcel$global.Uint8Array || function() {};
function $128e63aad4db5ad2$var$_uint8ArrayToBuffer(chunk) {
    return $128e63aad4db5ad2$require$Buffer.from(chunk);
}
function $128e63aad4db5ad2$var$_isUint8Array(obj) {
    return $128e63aad4db5ad2$require$Buffer.isBuffer(obj) || obj instanceof $128e63aad4db5ad2$var$OurUint8Array;
}

var $128e63aad4db5ad2$var$debug;
if ($5VgCY$util && $5VgCY$util.debuglog) $128e63aad4db5ad2$var$debug = $5VgCY$util.debuglog("stream");
else $128e63aad4db5ad2$var$debug = function debug() {};

var $anhJ2 = parcelRequire("anhJ2");

var $7dLEb = parcelRequire("7dLEb");

var $ftBwG = parcelRequire("ftBwG");
var $128e63aad4db5ad2$var$getHighWaterMark = $ftBwG.getHighWaterMark;

var $9cCav = parcelRequire("9cCav");
var $128e63aad4db5ad2$require$_require$codes = $9cCav.codes;
var $128e63aad4db5ad2$var$ERR_INVALID_ARG_TYPE = $128e63aad4db5ad2$require$_require$codes.ERR_INVALID_ARG_TYPE, $128e63aad4db5ad2$var$ERR_STREAM_PUSH_AFTER_EOF = $128e63aad4db5ad2$require$_require$codes.ERR_STREAM_PUSH_AFTER_EOF, $128e63aad4db5ad2$var$ERR_METHOD_NOT_IMPLEMENTED = $128e63aad4db5ad2$require$_require$codes.ERR_METHOD_NOT_IMPLEMENTED, $128e63aad4db5ad2$var$ERR_STREAM_UNSHIFT_AFTER_END_EVENT = $128e63aad4db5ad2$require$_require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.
var $128e63aad4db5ad2$var$StringDecoder;
var $128e63aad4db5ad2$var$createReadableStreamAsyncIterator;
var $128e63aad4db5ad2$var$from;

(parcelRequire("bo0qS"))($128e63aad4db5ad2$var$Readable, $dFjLx);
var $128e63aad4db5ad2$var$errorOrDestroy = $7dLEb.errorOrDestroy;
var $128e63aad4db5ad2$var$kProxyEvents = [
    "error",
    "close",
    "destroy",
    "pause",
    "resume"
];
function $128e63aad4db5ad2$var$prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [
        fn,
        emitter._events[event]
    ];
}


function $128e63aad4db5ad2$var$ReadableState(options, stream, isDuplex) {
    $128e63aad4db5ad2$var$Duplex = $128e63aad4db5ad2$var$Duplex || (parcelRequire("lWLE4"));
    options = options || {}; // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof $128e63aad4db5ad2$var$Duplex; // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    this.highWaterMark = $128e63aad4db5ad2$var$getHighWaterMark(this, options, "readableHighWaterMark", isDuplex); // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new $anhJ2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    this.sync = true; // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true; // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')
    this.autoDestroy = !!options.autoDestroy; // has it been destroyed
    this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8"; // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
        if (!$128e63aad4db5ad2$var$StringDecoder) $128e63aad4db5ad2$var$StringDecoder = (parcelRequire("gqFDJ")).StringDecoder;
        this.decoder = new $128e63aad4db5ad2$var$StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}

function $128e63aad4db5ad2$var$Readable(options) {
    $128e63aad4db5ad2$var$Duplex = $128e63aad4db5ad2$var$Duplex || (parcelRequire("lWLE4"));
    if (!(this instanceof $128e63aad4db5ad2$var$Readable)) return new $128e63aad4db5ad2$var$Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
    // the ReadableState constructor, at least with V8 6.5
    var isDuplex = this instanceof $128e63aad4db5ad2$var$Duplex;
    this._readableState = new $128e63aad4db5ad2$var$ReadableState(options, this, isDuplex); // legacy
    this.readable = true;
    if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    $dFjLx.call(this);
}
Object.defineProperty($128e63aad4db5ad2$var$Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined) return false;
        return this._readableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._readableState) return;
         // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
    }
});
$128e63aad4db5ad2$var$Readable.prototype.destroy = $7dLEb.destroy;
$128e63aad4db5ad2$var$Readable.prototype._undestroy = $7dLEb.undestroy;
$128e63aad4db5ad2$var$Readable.prototype._destroy = function(err, cb) {
    cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
$128e63aad4db5ad2$var$Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
                chunk = $128e63aad4db5ad2$require$Buffer.from(chunk, encoding);
                encoding = "";
            }
            skipChunkCheck = true;
        }
    } else skipChunkCheck = true;
    return $128e63aad4db5ad2$var$readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()
$128e63aad4db5ad2$var$Readable.prototype.unshift = function(chunk) {
    return $128e63aad4db5ad2$var$readableAddChunk(this, chunk, null, true, false);
};
function $128e63aad4db5ad2$var$readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    $128e63aad4db5ad2$var$debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
        state.reading = false;
        $128e63aad4db5ad2$var$onEofChunk(stream, state);
    } else {
        var er;
        if (!skipChunkCheck) er = $128e63aad4db5ad2$var$chunkInvalid(state, chunk);
        if (er) $128e63aad4db5ad2$var$errorOrDestroy(stream, er);
        else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== $128e63aad4db5ad2$require$Buffer.prototype) chunk = $128e63aad4db5ad2$var$_uint8ArrayToBuffer(chunk);
            if (addToFront) {
                if (state.endEmitted) $128e63aad4db5ad2$var$errorOrDestroy(stream, new $128e63aad4db5ad2$var$ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                else $128e63aad4db5ad2$var$addChunk(stream, state, chunk, true);
            } else if (state.ended) $128e63aad4db5ad2$var$errorOrDestroy(stream, new $128e63aad4db5ad2$var$ERR_STREAM_PUSH_AFTER_EOF());
            else if (state.destroyed) return false;
            else {
                state.reading = false;
                if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0) $128e63aad4db5ad2$var$addChunk(stream, state, chunk, false);
                    else $128e63aad4db5ad2$var$maybeReadMore(stream, state);
                } else $128e63aad4db5ad2$var$addChunk(stream, state, chunk, false);
            }
        } else if (!addToFront) {
            state.reading = false;
            $128e63aad4db5ad2$var$maybeReadMore(stream, state);
        }
    } // We can push more data if we are below the highWaterMark.
    // Also, if we have no data yet, we can stand some more bytes.
    // This is to work around cases where hwm=0, such as the repl.
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function $128e63aad4db5ad2$var$addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
    } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) $128e63aad4db5ad2$var$emitReadable(stream);
    }
    $128e63aad4db5ad2$var$maybeReadMore(stream, state);
}
function $128e63aad4db5ad2$var$chunkInvalid(state, chunk) {
    var er;
    if (!$128e63aad4db5ad2$var$_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) er = new $128e63aad4db5ad2$var$ERR_INVALID_ARG_TYPE("chunk", [
        "string",
        "Buffer",
        "Uint8Array"
    ], chunk);
    return er;
}
$128e63aad4db5ad2$var$Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
}; // backwards compatibility.

$128e63aad4db5ad2$var$Readable.prototype.setEncoding = function(enc) {
    if (!$128e63aad4db5ad2$var$StringDecoder) $128e63aad4db5ad2$var$StringDecoder = (parcelRequire("gqFDJ")).StringDecoder;
    var decoder = new $128e63aad4db5ad2$var$StringDecoder(enc);
    this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8
    this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:
    var p = this._readableState.buffer.head;
    var content = "";
    while(p !== null){
        content += decoder.write(p.data);
        p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
}; // Don't raise the hwm > 1GB
var $128e63aad4db5ad2$var$MAX_HWM = 0x40000000;
function $128e63aad4db5ad2$var$computeNewHighWaterMark(n) {
    if (n >= $128e63aad4db5ad2$var$MAX_HWM) // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = $128e63aad4db5ad2$var$MAX_HWM;
    else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.
function $128e63aad4db5ad2$var$howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
    } // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = $128e63aad4db5ad2$var$computeNewHighWaterMark(n);
    if (n <= state.length) return n; // Don't have enough
    if (!state.ended) {
        state.needReadable = true;
        return 0;
    }
    return state.length;
} // you can override either this method, or the async _read(n) below.
$128e63aad4db5ad2$var$Readable.prototype.read = function(n) {
    $128e63aad4db5ad2$var$debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        $128e63aad4db5ad2$var$debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) $128e63aad4db5ad2$var$endReadable(this);
        else $128e63aad4db5ad2$var$emitReadable(this);
        return null;
    }
    n = $128e63aad4db5ad2$var$howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
        if (state.length === 0) $128e63aad4db5ad2$var$endReadable(this);
        return null;
    } // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    $128e63aad4db5ad2$var$debug("need readable", doRead); // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        $128e63aad4db5ad2$var$debug("length less than watermark", doRead);
    } // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
        doRead = false;
        $128e63aad4db5ad2$var$debug("reading or ended", doRead);
    } else if (doRead) {
        $128e63aad4db5ad2$var$debug("do read");
        state.reading = true;
        state.sync = true; // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true; // call internal read method
        this._read(state.highWaterMark);
        state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = $128e63aad4db5ad2$var$howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0) ret = $128e63aad4db5ad2$var$fromList(n, state);
    else ret = null;
    if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
    } else {
        state.length -= n;
        state.awaitDrain = 0;
    }
    if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) $128e63aad4db5ad2$var$endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
};
function $128e63aad4db5ad2$var$onEofChunk(stream, state) {
    $128e63aad4db5ad2$var$debug("onEofChunk");
    if (state.ended) return;
    if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    if (state.sync) // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    $128e63aad4db5ad2$var$emitReadable(stream);
    else {
        // emit 'readable' now to make sure it gets picked up.
        state.needReadable = false;
        if (!state.emittedReadable) {
            state.emittedReadable = true;
            $128e63aad4db5ad2$var$emitReadable_(stream);
        }
    }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function $128e63aad4db5ad2$var$emitReadable(stream) {
    var state = stream._readableState;
    $128e63aad4db5ad2$var$debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
        $128e63aad4db5ad2$var$debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick($128e63aad4db5ad2$var$emitReadable_, stream);
    }
}
function $128e63aad4db5ad2$var$emitReadable_(stream) {
    var state = stream._readableState;
    $128e63aad4db5ad2$var$debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
    } // The stream needs another readable event if
    // 1. It is not flowing, as the flow mechanism will take
    //    care of it.
    // 2. It is not ended.
    // 3. It is below the highWaterMark, so we can schedule
    //    another readable later.
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    $128e63aad4db5ad2$var$flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function $128e63aad4db5ad2$var$maybeReadMore(stream, state) {
    if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick($128e63aad4db5ad2$var$maybeReadMore_, stream, state);
    }
}
function $128e63aad4db5ad2$var$maybeReadMore_(stream, state) {
    // Attempt to read more data if we should.
    //
    // The conditions for reading more data are (one of):
    // - Not enough data buffered (state.length < state.highWaterMark). The loop
    //   is responsible for filling the buffer with enough data if such data
    //   is available. If highWaterMark is 0 and we are not in the flowing mode
    //   we should _not_ attempt to buffer any extra data. We'll get more data
    //   when the stream consumer calls read() instead.
    // - No data in the buffer, and the stream is in flowing mode. In this mode
    //   the loop below is responsible for ensuring read() is called. Failing to
    //   call read here would abort the flow and there's no other mechanism for
    //   continuing the flow if the stream consumer has just subscribed to the
    //   'data' event.
    //
    // In addition to the above conditions to keep reading data, the following
    // conditions prevent the data from being read:
    // - The stream has ended (state.ended).
    // - There is already a pending 'read' operation (state.reading). This is a
    //   case where the the stream has called the implementation defined _read()
    //   method, but they are processing the call asynchronously and have _not_
    //   called push() with new data. In this case we skip performing more
    //   read()s. The execution ends in this method again after the _read() ends
    //   up calling push() with more data.
    while(!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)){
        var len = state.length;
        $128e63aad4db5ad2$var$debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length) break;
    }
    state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
$128e63aad4db5ad2$var$Readable.prototype._read = function(n) {
    $128e63aad4db5ad2$var$errorOrDestroy(this, new $128e63aad4db5ad2$var$ERR_METHOD_NOT_IMPLEMENTED("_read()"));
};
$128e63aad4db5ad2$var$Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch(state.pipesCount){
        case 0:
            state.pipes = dest;
            break;
        case 1:
            state.pipes = [
                state.pipes,
                dest
            ];
            break;
        default:
            state.pipes.push(dest);
            break;
    }
    state.pipesCount += 1;
    $128e63aad4db5ad2$var$debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) process.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        $128e63aad4db5ad2$var$debug("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        $128e63aad4db5ad2$var$debug("onend");
        dest.end();
    } // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = $128e63aad4db5ad2$var$pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
        $128e63aad4db5ad2$var$debug("cleanup"); // cleanup event handlers once the pipe is broken
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true; // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
        $128e63aad4db5ad2$var$debug("ondata");
        var ret = dest.write(chunk);
        $128e63aad4db5ad2$var$debug("dest.write", ret);
        if (ret === false) {
            // If the user unpiped during `dest.write()`, it is possible
            // to get stuck in a permanently paused state if that write
            // also returned false.
            // => Check whether `dest` is still a piping destination.
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && $128e63aad4db5ad2$var$indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                $128e63aad4db5ad2$var$debug("false write response, pause", state.awaitDrain);
                state.awaitDrain++;
            }
            src.pause();
        }
    } // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
        $128e63aad4db5ad2$var$debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if ($128e63aad4db5ad2$var$EElistenerCount(dest, "error") === 0) $128e63aad4db5ad2$var$errorOrDestroy(dest, er);
    } // Make sure our error handler is attached before userland ones.
    $128e63aad4db5ad2$var$prependListener(dest, "error", onerror); // Both close and finish should trigger unpipe, but only once.
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        $128e63aad4db5ad2$var$debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        $128e63aad4db5ad2$var$debug("unpipe");
        src.unpipe(dest);
    } // tell the dest that it's being piped to
    dest.emit("pipe", src); // start the flow if it hasn't been started already.
    if (!state.flowing) {
        $128e63aad4db5ad2$var$debug("pipe resume");
        src.resume();
    }
    return dest;
};
function $128e63aad4db5ad2$var$pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        $128e63aad4db5ad2$var$debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && $128e63aad4db5ad2$var$EElistenerCount(src, "data")) {
            state.flowing = true;
            $128e63aad4db5ad2$var$flow(src);
        }
    };
}
$128e63aad4db5ad2$var$Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
        hasUnpiped: false
    }; // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this; // just one destination.  most common case.
    if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes; // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
    } // slow case. multiple pipe destinations.
    if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for(var i = 0; i < len; i++)dests[i].emit("unpipe", this, {
            hasUnpiped: false
        });
        return this;
    } // try to find the right one.
    var index = $128e63aad4db5ad2$var$indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something
$128e63aad4db5ad2$var$Readable.prototype.on = function(ev, fn) {
    var res = $dFjLx.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
        // update readableListening so that resume() may be a no-op
        // a few lines down. This is needed to support once('readable').
        state.readableListening = this.listenerCount("readable") > 0; // Try start flowing on next tick if stream isn't explicitly paused
        if (state.flowing !== false) this.resume();
    } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            $128e63aad4db5ad2$var$debug("on readable", state.length, state.reading);
            if (state.length) $128e63aad4db5ad2$var$emitReadable(this);
            else if (!state.reading) process.nextTick($128e63aad4db5ad2$var$nReadingNextTick, this);
        }
    }
    return res;
};
$128e63aad4db5ad2$var$Readable.prototype.addListener = $128e63aad4db5ad2$var$Readable.prototype.on;
$128e63aad4db5ad2$var$Readable.prototype.removeListener = function(ev, fn) {
    var res = $dFjLx.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick($128e63aad4db5ad2$var$updateReadableListening, this);
    return res;
};
$128e63aad4db5ad2$var$Readable.prototype.removeAllListeners = function(ev) {
    var res = $dFjLx.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick($128e63aad4db5ad2$var$updateReadableListening, this);
    return res;
};
function $128e63aad4db5ad2$var$updateReadableListening(self) {
    var state = self._readableState;
    state.readableListening = self.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
    else if (self.listenerCount("data") > 0) self.resume();
}
function $128e63aad4db5ad2$var$nReadingNextTick(self) {
    $128e63aad4db5ad2$var$debug("readable nexttick read 0");
    self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
$128e63aad4db5ad2$var$Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
        $128e63aad4db5ad2$var$debug("resume"); // we flow only if there is no one listening
        // for readable, but we still have to call
        // resume()
        state.flowing = !state.readableListening;
        $128e63aad4db5ad2$var$resume(this, state);
    }
    state.paused = false;
    return this;
};
function $128e63aad4db5ad2$var$resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick($128e63aad4db5ad2$var$resume_, stream, state);
    }
}
function $128e63aad4db5ad2$var$resume_(stream, state) {
    $128e63aad4db5ad2$var$debug("resume", state.reading);
    if (!state.reading) stream.read(0);
    state.resumeScheduled = false;
    stream.emit("resume");
    $128e63aad4db5ad2$var$flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
}
$128e63aad4db5ad2$var$Readable.prototype.pause = function() {
    $128e63aad4db5ad2$var$debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        $128e63aad4db5ad2$var$debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
};
function $128e63aad4db5ad2$var$flow(stream) {
    var state = stream._readableState;
    $128e63aad4db5ad2$var$debug("flow", state.flowing);
    while(state.flowing && stream.read() !== null);
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
$128e63aad4db5ad2$var$Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
        $128e63aad4db5ad2$var$debug("wrapped end");
        if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
    });
    stream.on("data", function(chunk) {
        $128e63aad4db5ad2$var$debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
            paused = true;
            stream.pause();
        }
    }); // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for(var i in stream)if (this[i] === undefined && typeof stream[i] === "function") this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
        };
    }(i);
     // proxy certain important events.
    for(var n = 0; n < $128e63aad4db5ad2$var$kProxyEvents.length; n++)stream.on($128e63aad4db5ad2$var$kProxyEvents[n], this.emit.bind(this, $128e63aad4db5ad2$var$kProxyEvents[n]));
     // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function(n) {
        $128e63aad4db5ad2$var$debug("wrapped _read", n);
        if (paused) {
            paused = false;
            stream.resume();
        }
    };
    return this;
};

if (typeof Symbol === "function") $128e63aad4db5ad2$var$Readable.prototype[Symbol.asyncIterator] = function() {
    if ($128e63aad4db5ad2$var$createReadableStreamAsyncIterator === undefined) $128e63aad4db5ad2$var$createReadableStreamAsyncIterator = (parcelRequire("564vG"));
    return $128e63aad4db5ad2$var$createReadableStreamAsyncIterator(this);
};
Object.defineProperty($128e63aad4db5ad2$var$Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.highWaterMark;
    }
});
Object.defineProperty($128e63aad4db5ad2$var$Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState && this._readableState.buffer;
    }
});
Object.defineProperty($128e63aad4db5ad2$var$Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.flowing;
    },
    set: function set(state) {
        if (this._readableState) this._readableState.flowing = state;
    }
}); // exposed for testing purposes only.
$128e63aad4db5ad2$var$Readable._fromList = $128e63aad4db5ad2$var$fromList;
Object.defineProperty($128e63aad4db5ad2$var$Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.length;
    }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function $128e63aad4db5ad2$var$fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
    } else // read part of list
    ret = state.buffer.consume(n, state.decoder);
    return ret;
}
function $128e63aad4db5ad2$var$endReadable(stream) {
    var state = stream._readableState;
    $128e63aad4db5ad2$var$debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
        state.ended = true;
        process.nextTick($128e63aad4db5ad2$var$endReadableNT, state, stream);
    }
}
function $128e63aad4db5ad2$var$endReadableNT(state, stream) {
    $128e63aad4db5ad2$var$debug("endReadableNT", state.endEmitted, state.length); // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
            // In case of duplex streams we need a way to detect
            // if the writable side is ready for autoDestroy as well
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) stream.destroy();
        }
    }
}

if (typeof Symbol === "function") $128e63aad4db5ad2$var$Readable.from = function(iterable, opts) {
    if ($128e63aad4db5ad2$var$from === undefined) $128e63aad4db5ad2$var$from = (parcelRequire("FMyqb"));
    return $128e63aad4db5ad2$var$from($128e63aad4db5ad2$var$Readable, iterable, opts);
};
function $128e63aad4db5ad2$var$indexOf(xs, x) {
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) return i;
    }
    return -1;
}

});
parcelRequire.register("dFjLx", function(module, exports) {

module.exports = $5VgCY$stream;

});

parcelRequire.register("anhJ2", function(module, exports) {
"use strict";
function $78d9cd42bc92bbdd$var$ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function $78d9cd42bc92bbdd$var$_objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) $78d9cd42bc92bbdd$var$ownKeys(Object(source), true).forEach(function(key) {
            $78d9cd42bc92bbdd$var$_defineProperty(target, key, source[key]);
        });
        else if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        else $78d9cd42bc92bbdd$var$ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function $78d9cd42bc92bbdd$var$_defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function $78d9cd42bc92bbdd$var$_classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function $78d9cd42bc92bbdd$var$_defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function $78d9cd42bc92bbdd$var$_createClass(Constructor, protoProps, staticProps) {
    if (protoProps) $78d9cd42bc92bbdd$var$_defineProperties(Constructor.prototype, protoProps);
    if (staticProps) $78d9cd42bc92bbdd$var$_defineProperties(Constructor, staticProps);
    return Constructor;
}

var $78d9cd42bc92bbdd$var$Buffer = $5VgCY$buffer.Buffer;

var $78d9cd42bc92bbdd$var$inspect = $5VgCY$util.inspect;
var $78d9cd42bc92bbdd$var$custom = $78d9cd42bc92bbdd$var$inspect && $78d9cd42bc92bbdd$var$inspect.custom || "inspect";
function $78d9cd42bc92bbdd$var$copyBuffer(src, target, offset) {
    $78d9cd42bc92bbdd$var$Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/ function() {
    function BufferList() {
        $78d9cd42bc92bbdd$var$_classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    $78d9cd42bc92bbdd$var$_createClass(BufferList, [
        {
            key: "push",
            value: function push(v) {
                var entry = {
                    data: v,
                    next: null
                };
                if (this.length > 0) this.tail.next = entry;
                else this.head = entry;
                this.tail = entry;
                ++this.length;
            }
        },
        {
            key: "unshift",
            value: function unshift(v) {
                var entry = {
                    data: v,
                    next: this.head
                };
                if (this.length === 0) this.tail = entry;
                this.head = entry;
                ++this.length;
            }
        },
        {
            key: "shift",
            value: function shift() {
                if (this.length === 0) return;
                var ret = this.head.data;
                if (this.length === 1) this.head = this.tail = null;
                else this.head = this.head.next;
                --this.length;
                return ret;
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.head = this.tail = null;
                this.length = 0;
            }
        },
        {
            key: "join",
            value: function join(s) {
                if (this.length === 0) return "";
                var p = this.head;
                var ret = "" + p.data;
                while(p = p.next)ret += s + p.data;
                return ret;
            }
        },
        {
            key: "concat",
            value: function concat(n) {
                if (this.length === 0) return $78d9cd42bc92bbdd$var$Buffer.alloc(0);
                var ret = $78d9cd42bc92bbdd$var$Buffer.allocUnsafe(n >>> 0);
                var p = this.head;
                var i = 0;
                while(p){
                    $78d9cd42bc92bbdd$var$copyBuffer(p.data, ret, i);
                    i += p.data.length;
                    p = p.next;
                }
                return ret;
            } // Consumes a specified amount of bytes or characters from the buffered data.
        },
        {
            key: "consume",
            value: function consume(n, hasStrings) {
                var ret;
                if (n < this.head.data.length) {
                    // `slice` is the same for buffers and strings.
                    ret = this.head.data.slice(0, n);
                    this.head.data = this.head.data.slice(n);
                } else if (n === this.head.data.length) // First chunk is a perfect match.
                ret = this.shift();
                else // Result spans more than one buffer.
                ret = hasStrings ? this._getString(n) : this._getBuffer(n);
                return ret;
            }
        },
        {
            key: "first",
            value: function first() {
                return this.head.data;
            } // Consumes a specified amount of characters from the buffered data.
        },
        {
            key: "_getString",
            value: function _getString(n) {
                var p = this.head;
                var c = 1;
                var ret = p.data;
                n -= ret.length;
                while(p = p.next){
                    var str = p.data;
                    var nb = n > str.length ? str.length : n;
                    if (nb === str.length) ret += str;
                    else ret += str.slice(0, n);
                    n -= nb;
                    if (n === 0) {
                        if (nb === str.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = str.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            } // Consumes a specified amount of bytes from the buffered data.
        },
        {
            key: "_getBuffer",
            value: function _getBuffer(n) {
                var ret = $78d9cd42bc92bbdd$var$Buffer.allocUnsafe(n);
                var p = this.head;
                var c = 1;
                p.data.copy(ret);
                n -= p.data.length;
                while(p = p.next){
                    var buf = p.data;
                    var nb = n > buf.length ? buf.length : n;
                    buf.copy(ret, ret.length - n, 0, nb);
                    n -= nb;
                    if (n === 0) {
                        if (nb === buf.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = buf.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            } // Make sure the linked list only shows the minimal necessary information.
        },
        {
            key: $78d9cd42bc92bbdd$var$custom,
            value: function value(_, options) {
                return $78d9cd42bc92bbdd$var$inspect(this, $78d9cd42bc92bbdd$var$_objectSpread({}, options, {
                    // Only inspect one level.
                    depth: 0,
                    // It should not recurse.
                    customInspect: false
                }));
            }
        }
    ]);
    return BufferList;
}();

});

parcelRequire.register("7dLEb", function(module, exports) {
"use strict"; // undocumented cb() API, needed for core, not for public API
function $541eb508c9adb89c$var$destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
        if (cb) cb(err);
        else if (err) {
            if (!this._writableState) process.nextTick($541eb508c9adb89c$var$emitErrorNT, this, err);
            else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                process.nextTick($541eb508c9adb89c$var$emitErrorNT, this, err);
            }
        }
        return this;
    } // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
    if (this._readableState) this._readableState.destroyed = true;
     // if this is a duplex stream mark the writable part as destroyed as well
    if (this._writableState) this._writableState.destroyed = true;
    this._destroy(err || null, function(err) {
        if (!cb && err) {
            if (!_this._writableState) process.nextTick($541eb508c9adb89c$var$emitErrorAndCloseNT, _this, err);
            else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                process.nextTick($541eb508c9adb89c$var$emitErrorAndCloseNT, _this, err);
            } else process.nextTick($541eb508c9adb89c$var$emitCloseNT, _this);
        } else if (cb) {
            process.nextTick($541eb508c9adb89c$var$emitCloseNT, _this);
            cb(err);
        } else process.nextTick($541eb508c9adb89c$var$emitCloseNT, _this);
    });
    return this;
}
function $541eb508c9adb89c$var$emitErrorAndCloseNT(self, err) {
    $541eb508c9adb89c$var$emitErrorNT(self, err);
    $541eb508c9adb89c$var$emitCloseNT(self);
}
function $541eb508c9adb89c$var$emitCloseNT(self) {
    if (self._writableState && !self._writableState.emitClose) return;
    if (self._readableState && !self._readableState.emitClose) return;
    self.emit("close");
}
function $541eb508c9adb89c$var$undestroy() {
    if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
    }
    if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
    }
}
function $541eb508c9adb89c$var$emitErrorNT(self, err) {
    self.emit("error", err);
}
function $541eb508c9adb89c$var$errorOrDestroy(stream, err) {
    // We have tests that rely on errors being emitted
    // in the same tick, so changing this is semver major.
    // For now when you opt-in to autoDestroy we allow
    // the error to be emitted nextTick. In a future
    // semver major update we should change the default to this.
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit("error", err);
}
module.exports = {
    destroy: $541eb508c9adb89c$var$destroy,
    undestroy: $541eb508c9adb89c$var$undestroy,
    errorOrDestroy: $541eb508c9adb89c$var$errorOrDestroy
};

});

parcelRequire.register("ftBwG", function(module, exports) {
"use strict";

var $9cCav = parcelRequire("9cCav");
var $b446ac5e8a55fa99$var$ERR_INVALID_OPT_VALUE = $9cCav.codes.ERR_INVALID_OPT_VALUE;
function $b446ac5e8a55fa99$var$highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function $b446ac5e8a55fa99$var$getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = $b446ac5e8a55fa99$var$highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new $b446ac5e8a55fa99$var$ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
    } // Default value
    return state.objectMode ? 16 : 16384;
}
module.exports = {
    getHighWaterMark: $b446ac5e8a55fa99$var$getHighWaterMark
};

});
parcelRequire.register("9cCav", function(module, exports) {

$parcel$export(module.exports, "codes", () => $6b32d786bb610a09$export$e45cb6485273080e, (v) => $6b32d786bb610a09$export$e45cb6485273080e = v);
var $6b32d786bb610a09$export$e45cb6485273080e;
"use strict";
const $6b32d786bb610a09$var$codes = {};
function $6b32d786bb610a09$var$createErrorType(code, message, Base) {
    if (!Base) Base = Error;
    function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") return message;
        else return message(arg1, arg2, arg3);
    }
    class NodeError extends Base {
        constructor(arg1, arg2, arg3){
            super(getMessage(arg1, arg2, arg3));
        }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    $6b32d786bb610a09$var$codes[code] = NodeError;
}
// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function $6b32d786bb610a09$var$oneOf(expected, thing) {
    if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i)=>String(i));
        if (len > 2) return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        else if (len === 2) return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        else return `of ${thing} ${expected[0]}`;
    } else return `of ${thing} ${String(expected)}`;
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function $6b32d786bb610a09$var$startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function $6b32d786bb610a09$var$endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) this_len = str.length;
    return str.substring(this_len - search.length, this_len) === search;
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function $6b32d786bb610a09$var$includes(str, search, start) {
    if (typeof start !== "number") start = 0;
    if (start + search.length > str.length) return false;
    else return str.indexOf(search, start) !== -1;
}
$6b32d786bb610a09$var$createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
$6b32d786bb610a09$var$createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    // determiner: 'must be' or 'must not be'
    let determiner;
    if (typeof expected === "string" && $6b32d786bb610a09$var$startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
    } else determiner = "must be";
    let msg;
    if ($6b32d786bb610a09$var$endsWith(name, " argument")) // For cases like 'first argument'
    msg = `The ${name} ${determiner} ${$6b32d786bb610a09$var$oneOf(expected, "type")}`;
    else {
        const type = $6b32d786bb610a09$var$includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${$6b32d786bb610a09$var$oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
}, TypeError);
$6b32d786bb610a09$var$createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
$6b32d786bb610a09$var$createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
});
$6b32d786bb610a09$var$createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
$6b32d786bb610a09$var$createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
});
$6b32d786bb610a09$var$createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
$6b32d786bb610a09$var$createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
$6b32d786bb610a09$var$createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
$6b32d786bb610a09$var$createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
$6b32d786bb610a09$var$createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
}, TypeError);
$6b32d786bb610a09$var$createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
$6b32d786bb610a09$export$e45cb6485273080e = $6b32d786bb610a09$var$codes;

});


parcelRequire.register("bo0qS", function(module, exports) {


try {
    var $84a2457974d425b3$var$util = $84a2457974d425b3$import$57f6e86051212e1;
    /* istanbul ignore next */ if (typeof $84a2457974d425b3$var$util.inherits !== "function") throw "";
    module.exports = $84a2457974d425b3$var$util.inherits;
} catch (e) {
    /* istanbul ignore next */ module.exports = (parcelRequire("404Fy"));
}

});
parcelRequire.register("404Fy", function(module, exports) {
if (typeof Object.create === "function") // implementation from standard node.js 'util' module
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    }
};
else // old school shim for old browsers
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
};

});


parcelRequire.register("lWLE4", function(module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
"use strict";
/*<replacement>*/ var $ffa3f91e538fcd25$var$objectKeys = Object.keys || function(obj) {
    var keys = [];
    for(var key in obj)keys.push(key);
    return keys;
};
/*</replacement>*/ module.exports = $ffa3f91e538fcd25$var$Duplex;

var $1AM0g = parcelRequire("1AM0g");

var $5rzHA = parcelRequire("5rzHA");

(parcelRequire("bo0qS"))($ffa3f91e538fcd25$var$Duplex, $1AM0g);
// Allow the keys array to be GC'ed.
var $ffa3f91e538fcd25$var$keys = $ffa3f91e538fcd25$var$objectKeys($5rzHA.prototype);
for(var $ffa3f91e538fcd25$var$v = 0; $ffa3f91e538fcd25$var$v < $ffa3f91e538fcd25$var$keys.length; $ffa3f91e538fcd25$var$v++){
    var $ffa3f91e538fcd25$var$method = $ffa3f91e538fcd25$var$keys[$ffa3f91e538fcd25$var$v];
    if (!$ffa3f91e538fcd25$var$Duplex.prototype[$ffa3f91e538fcd25$var$method]) $ffa3f91e538fcd25$var$Duplex.prototype[$ffa3f91e538fcd25$var$method] = $5rzHA.prototype[$ffa3f91e538fcd25$var$method];
}
function $ffa3f91e538fcd25$var$Duplex(options) {
    if (!(this instanceof $ffa3f91e538fcd25$var$Duplex)) return new $ffa3f91e538fcd25$var$Duplex(options);
    $1AM0g.call(this, options);
    $5rzHA.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", $ffa3f91e538fcd25$var$onend);
        }
    }
}
Object.defineProperty($ffa3f91e538fcd25$var$Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
Object.defineProperty($ffa3f91e538fcd25$var$Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
Object.defineProperty($ffa3f91e538fcd25$var$Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
}); // the no-half-open enforcer
function $ffa3f91e538fcd25$var$onend() {
    // If the writable side ended, then we're ok.
    if (this._writableState.ended) return; // no more data can be written.
    // But allow more writes to happen in this tick.
    process.nextTick($ffa3f91e538fcd25$var$onEndNT, this);
}
function $ffa3f91e538fcd25$var$onEndNT(self) {
    self.end();
}
Object.defineProperty($ffa3f91e538fcd25$var$Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined || this._writableState === undefined) return false;
        return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (this._readableState === undefined || this._writableState === undefined) return;
         // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
    }
});

});
parcelRequire.register("5rzHA", function(module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
"use strict";
module.exports = $3f6b2b080bf7a4f7$var$Writable;
/* <replacement> */ function $3f6b2b080bf7a4f7$var$WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream
function $3f6b2b080bf7a4f7$var$CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
        $3f6b2b080bf7a4f7$var$onCorkedFinish(_this, state);
    };
}
/* </replacement> */ /*<replacement>*/ var $3f6b2b080bf7a4f7$var$Duplex;
/*</replacement>*/ $3f6b2b080bf7a4f7$var$Writable.WritableState = $3f6b2b080bf7a4f7$var$WritableState;

/*<replacement>*/ var $3f6b2b080bf7a4f7$var$internalUtil = {
    deprecate: (parcelRequire("5gyXW"))
};

var $dFjLx = parcelRequire("dFjLx");

var $3f6b2b080bf7a4f7$require$Buffer = $5VgCY$buffer.Buffer;
var $3f6b2b080bf7a4f7$var$OurUint8Array = $parcel$global.Uint8Array || function() {};
function $3f6b2b080bf7a4f7$var$_uint8ArrayToBuffer(chunk) {
    return $3f6b2b080bf7a4f7$require$Buffer.from(chunk);
}
function $3f6b2b080bf7a4f7$var$_isUint8Array(obj) {
    return $3f6b2b080bf7a4f7$require$Buffer.isBuffer(obj) || obj instanceof $3f6b2b080bf7a4f7$var$OurUint8Array;
}

var $7dLEb = parcelRequire("7dLEb");

var $ftBwG = parcelRequire("ftBwG");
var $3f6b2b080bf7a4f7$var$getHighWaterMark = $ftBwG.getHighWaterMark;

var $9cCav = parcelRequire("9cCav");
var $3f6b2b080bf7a4f7$require$_require$codes = $9cCav.codes;
var $3f6b2b080bf7a4f7$var$ERR_INVALID_ARG_TYPE = $3f6b2b080bf7a4f7$require$_require$codes.ERR_INVALID_ARG_TYPE, $3f6b2b080bf7a4f7$var$ERR_METHOD_NOT_IMPLEMENTED = $3f6b2b080bf7a4f7$require$_require$codes.ERR_METHOD_NOT_IMPLEMENTED, $3f6b2b080bf7a4f7$var$ERR_MULTIPLE_CALLBACK = $3f6b2b080bf7a4f7$require$_require$codes.ERR_MULTIPLE_CALLBACK, $3f6b2b080bf7a4f7$var$ERR_STREAM_CANNOT_PIPE = $3f6b2b080bf7a4f7$require$_require$codes.ERR_STREAM_CANNOT_PIPE, $3f6b2b080bf7a4f7$var$ERR_STREAM_DESTROYED = $3f6b2b080bf7a4f7$require$_require$codes.ERR_STREAM_DESTROYED, $3f6b2b080bf7a4f7$var$ERR_STREAM_NULL_VALUES = $3f6b2b080bf7a4f7$require$_require$codes.ERR_STREAM_NULL_VALUES, $3f6b2b080bf7a4f7$var$ERR_STREAM_WRITE_AFTER_END = $3f6b2b080bf7a4f7$require$_require$codes.ERR_STREAM_WRITE_AFTER_END, $3f6b2b080bf7a4f7$var$ERR_UNKNOWN_ENCODING = $3f6b2b080bf7a4f7$require$_require$codes.ERR_UNKNOWN_ENCODING;
var $3f6b2b080bf7a4f7$var$errorOrDestroy = $7dLEb.errorOrDestroy;

(parcelRequire("bo0qS"))($3f6b2b080bf7a4f7$var$Writable, $dFjLx);
function $3f6b2b080bf7a4f7$var$nop() {}

function $3f6b2b080bf7a4f7$var$WritableState(options, stream, isDuplex) {
    $3f6b2b080bf7a4f7$var$Duplex = $3f6b2b080bf7a4f7$var$Duplex || (parcelRequire("lWLE4"));
    options = options || {}; // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream,
    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof $3f6b2b080bf7a4f7$var$Duplex; // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    this.highWaterMark = $3f6b2b080bf7a4f7$var$getHighWaterMark(this, options, "writableHighWaterMark", isDuplex); // if _final has been called
    this.finalCalled = false; // drain event flag.
    this.needDrain = false; // at the start of calling end()
    this.ending = false; // when end() has been called, and returned
    this.ended = false; // when 'finish' is emitted
    this.finished = false; // has it been destroyed
    this.destroyed = false; // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8"; // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0; // a flag to see when we're in the middle of a write.
    this.writing = false; // when true all writes will be buffered until .uncork() call
    this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true; // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)
    this.onwrite = function(er) {
        $3f6b2b080bf7a4f7$var$onwrite(stream, er);
    }; // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null; // the amount that is being written when _write is called.
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false; // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')
    this.autoDestroy = !!options.autoDestroy; // count buffered requests
    this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new $3f6b2b080bf7a4f7$var$CorkedRequest(this);
}
$3f6b2b080bf7a4f7$var$WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while(current){
        out.push(current);
        current = current.next;
    }
    return out;
};
(function() {
    try {
        Object.defineProperty($3f6b2b080bf7a4f7$var$WritableState.prototype, "buffer", {
            get: $3f6b2b080bf7a4f7$var$internalUtil.deprecate(function writableStateBufferGetter() {
                return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
    } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var $3f6b2b080bf7a4f7$var$realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    $3f6b2b080bf7a4f7$var$realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty($3f6b2b080bf7a4f7$var$Writable, Symbol.hasInstance, {
        value: function value(object) {
            if ($3f6b2b080bf7a4f7$var$realHasInstance.call(this, object)) return true;
            if (this !== $3f6b2b080bf7a4f7$var$Writable) return false;
            return object && object._writableState instanceof $3f6b2b080bf7a4f7$var$WritableState;
        }
    });
} else $3f6b2b080bf7a4f7$var$realHasInstance = function realHasInstance(object) {
    return object instanceof this;
};

function $3f6b2b080bf7a4f7$var$Writable(options) {
    $3f6b2b080bf7a4f7$var$Duplex = $3f6b2b080bf7a4f7$var$Duplex || (parcelRequire("lWLE4")); // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the WritableState constructor, at least with V8 6.5
    var isDuplex = this instanceof $3f6b2b080bf7a4f7$var$Duplex;
    if (!isDuplex && !$3f6b2b080bf7a4f7$var$realHasInstance.call($3f6b2b080bf7a4f7$var$Writable, this)) return new $3f6b2b080bf7a4f7$var$Writable(options);
    this._writableState = new $3f6b2b080bf7a4f7$var$WritableState(options, this, isDuplex); // legacy.
    this.writable = true;
    if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
    }
    $dFjLx.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.
$3f6b2b080bf7a4f7$var$Writable.prototype.pipe = function() {
    $3f6b2b080bf7a4f7$var$errorOrDestroy(this, new $3f6b2b080bf7a4f7$var$ERR_STREAM_CANNOT_PIPE());
};
function $3f6b2b080bf7a4f7$var$writeAfterEnd(stream, cb) {
    var er = new $3f6b2b080bf7a4f7$var$ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb
    $3f6b2b080bf7a4f7$var$errorOrDestroy(stream, er);
    process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function $3f6b2b080bf7a4f7$var$validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) er = new $3f6b2b080bf7a4f7$var$ERR_STREAM_NULL_VALUES();
    else if (typeof chunk !== "string" && !state.objectMode) er = new $3f6b2b080bf7a4f7$var$ERR_INVALID_ARG_TYPE("chunk", [
        "string",
        "Buffer"
    ], chunk);
    if (er) {
        $3f6b2b080bf7a4f7$var$errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
    }
    return true;
}
$3f6b2b080bf7a4f7$var$Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && $3f6b2b080bf7a4f7$var$_isUint8Array(chunk);
    if (isBuf && !$3f6b2b080bf7a4f7$require$Buffer.isBuffer(chunk)) chunk = $3f6b2b080bf7a4f7$var$_uint8ArrayToBuffer(chunk);
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== "function") cb = $3f6b2b080bf7a4f7$var$nop;
    if (state.ending) $3f6b2b080bf7a4f7$var$writeAfterEnd(this, cb);
    else if (isBuf || $3f6b2b080bf7a4f7$var$validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = $3f6b2b080bf7a4f7$var$writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
};
$3f6b2b080bf7a4f7$var$Writable.prototype.cork = function() {
    this._writableState.corked++;
};
$3f6b2b080bf7a4f7$var$Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) $3f6b2b080bf7a4f7$var$clearBuffer(this, state);
    }
};
$3f6b2b080bf7a4f7$var$Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!([
        "hex",
        "utf8",
        "utf-8",
        "ascii",
        "binary",
        "base64",
        "ucs2",
        "ucs-2",
        "utf16le",
        "utf-16le",
        "raw"
    ].indexOf((encoding + "").toLowerCase()) > -1)) throw new $3f6b2b080bf7a4f7$var$ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
};
Object.defineProperty($3f6b2b080bf7a4f7$var$Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
function $3f6b2b080bf7a4f7$var$decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") chunk = $3f6b2b080bf7a4f7$require$Buffer.from(chunk, encoding);
    return chunk;
}
Object.defineProperty($3f6b2b080bf7a4f7$var$Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function $3f6b2b080bf7a4f7$var$writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
        var newChunk = $3f6b2b080bf7a4f7$var$decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
        }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
            chunk: chunk,
            encoding: encoding,
            isBuf: isBuf,
            callback: cb,
            next: null
        };
        if (last) last.next = state.lastBufferedRequest;
        else state.bufferedRequest = state.lastBufferedRequest;
        state.bufferedRequestCount += 1;
    } else $3f6b2b080bf7a4f7$var$doWrite(stream, state, false, len, chunk, encoding, cb);
    return ret;
}
function $3f6b2b080bf7a4f7$var$doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) state.onwrite(new $3f6b2b080bf7a4f7$var$ERR_STREAM_DESTROYED("write"));
    else if (writev) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
}
function $3f6b2b080bf7a4f7$var$onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
        // defer the callback if we are being called synchronously
        // to avoid piling up things on the stack
        process.nextTick(cb, er); // this can emit finish, and it will always happen
        // after error
        process.nextTick($3f6b2b080bf7a4f7$var$finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        $3f6b2b080bf7a4f7$var$errorOrDestroy(stream, er);
    } else {
        // the caller expect this to happen before if
        // it is async
        cb(er);
        stream._writableState.errorEmitted = true;
        $3f6b2b080bf7a4f7$var$errorOrDestroy(stream, er); // this can emit finish, but finish must
        // always follow error
        $3f6b2b080bf7a4f7$var$finishMaybe(stream, state);
    }
}
function $3f6b2b080bf7a4f7$var$onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
}
function $3f6b2b080bf7a4f7$var$onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function") throw new $3f6b2b080bf7a4f7$var$ERR_MULTIPLE_CALLBACK();
    $3f6b2b080bf7a4f7$var$onwriteStateUpdate(state);
    if (er) $3f6b2b080bf7a4f7$var$onwriteError(stream, state, sync, er, cb);
    else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = $3f6b2b080bf7a4f7$var$needFinish(state) || strea